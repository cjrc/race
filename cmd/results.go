// Copyright Â© 2019 CJRC, Inc <greg@jrc.us>
//

package cmd

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/cjrc/race/model"
	"github.com/fsnotify/fsnotify"
	"github.com/spf13/cobra"
)

var doneCh chan bool
var liveResults bool

// tallyCmd represents the tally command
var resultsCmd = &cobra.Command{
	Use:   "results",
	Short: "Import the race results for each event",
	Long: `A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
	Run: func(cmd *cobra.Command, args []string) {
		if err := importResults(); err != nil {
			fmt.Println("Error importing results:", err)
			os.Exit(1)
		}
		if liveResults {
			importLiveResults()
		}
	},
}

func addResultsToDatabase(results []model.Result) error {
	db := DBMustConnect()

	for _, result := range results {
		// ignore empty results
		if result.BibNum == 0 {
			continue
		}
		fmt.Printf("Adding results for %s (bib # %d)..", result.Name, result.BibNum)
		ok, err := result.Insert(db)
		if err != nil {
			return err
		}
		if !ok {
			fmt.Println(" duplicate results, ignored.")
		} else {
			fmt.Println(" done.")
		}
	}

	return nil

}

func importResults() error {
	// find all the results files in the configured results path
	filenames, err := filepath.Glob(filepath.Join(C.ResultsPath, "*.txt"))
	if err != nil {
		return err
	}

	for _, filename := range filenames {
		fmt.Println("Reading results from", filename)
		results, err := model.ReadResultsFromFile(filename)
		if err != nil {
			return err
		}
		if err := addResultsToDatabase(results); err != nil {
			return err
		}
	}

	return nil
}

// watchResults will importResults and the results files are generated by
// the venue racing software
func watchResults(watcher *fsnotify.Watcher) {
	for {
		fmt.Println("\nWaiting for live results..")
		select {
		case event := <-watcher.Events:
			if event.Op&fsnotify.Write == fsnotify.Write {
				fmt.Println("Reading results from", event.Name)
				results, err := model.ReadResultsFromFile(event.Name)
				if err != nil {
					fmt.Println("Error reading results:", err)
					doneCh <- true
				}
				if err := addResultsToDatabase(results); err != nil {
					fmt.Println("Error saving results:", err)
					doneCh <- true
				}
			}
		case err := <-watcher.Errors:
			fmt.Println("Error watching:", err)
			doneCh <- true
		}
	}
}

func importLiveResults() {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		fmt.Println("Cannot create watcher:", err)
		os.Exit(1)
	}
	defer watcher.Close()

	doneCh = make(chan bool)
	go watchResults(watcher)

	err = watcher.Add(C.ResultsPath)
	if err != nil {
		fmt.Println("Cannot watch results:", err)
		os.Exit(1)
	}

	<-doneCh
}

func init() {
	importCmd.AddCommand(resultsCmd)

	resultsCmd.Flags().BoolVar(&liveResults, "live", false, "Watch the results path and tally events as new results arrive")

}
